<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Spinning Layers</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }

        h1 {
            font-size: 16px;
            margin: 0 0 5px 0;
            color: #fff;
        }

        p {
            font-size: 12px;
            margin: 0;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>Gravity Trap</h1>
        <p>Outer rings spin faster.</p>
        <p>Click to reset ball.</p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, centerX, centerY;
        let ball;
        let rings = [];
        const NUM_RINGS = 10;
        
        // Configuration
        const GRAVITY = 0.18;
        const FRICTION = 1.0; 
        const BOUNCE = 1.0; 
        const ROTATION_BASE_SPEED = 0.005;
        
        class Ball {
            constructor() {
                this.reset();
                this.radius = 6; 
                this.color = '#fff';
            }

            reset() {
                this.x = 0;
                this.y = -10; 
                this.vx = (Math.random() - 0.5) * 4; 
                this.vy = 0;
                this.history = []; 
            }

            update() {
                this.vy += GRAVITY;
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                this.x += this.vx;
                this.y += this.vy;

                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    this.history.push({x: this.x, y: this.y});
                    if (this.history.length > 15) this.history.shift();
                }
            }

            draw(ctx) {
                ctx.beginPath();
                for (let i = 0; i < this.history.length; i++) {
                    const point = this.history[i];
                    ctx.lineTo(point.x + centerX, point.y + centerY);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(this.x + centerX, this.y + centerY, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fff';
                ctx.fill();
                ctx.shadowBlur = 0; 
            }
        }

        class Ring {
            constructor(index, totalRings) {
                this.index = index;
                this.baseRadius = 30;
                this.radiusStep = 22; 
                this.radius = this.baseRadius + (index * this.radiusStep);
                this.thickness = 4;
                
                this.angle = Math.random() * Math.PI * 2;
                
                const speedMultiplier = 0.5 + (index / totalRings) * 1.5;
                // Removed random direction so they all spin in the same direction
                const dir = 1; 
                this.speed = ROTATION_BASE_SPEED * speedMultiplier * dir;

                this.gapSize = Math.PI / 3.5; 
                if (this.gapSize < Math.PI / 6) this.gapSize = Math.PI / 6;

                const hue = 180 + (index * 15);
                this.color = `hsl(${hue}, 70%, 60%)`;
            }

            update() {
                this.angle += this.speed;
            }

            draw(ctx) {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.thickness;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                const startAngle = this.angle + this.gapSize / 2;
                const endAngle = this.angle + Math.PI * 2 - this.gapSize / 2;
                
                ctx.arc(centerX, centerY, this.radius, startAngle, endAngle);
                ctx.stroke();
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;

            ball = new Ball();
            resetGame();
        }

        function resetGame() {
            ball.reset();
            rings = [];
            for (let i = 0; i < NUM_RINGS; i++) {
                rings.push(new Ring(i, NUM_RINGS));
            }
        }

        function checkCollisions() {
            const distSq = ball.x * ball.x + ball.y * ball.y;
            const dist = Math.sqrt(distSq);
            
            for (let i = rings.length - 1; i >= 0; i--) {
                const ring = rings[i];
                if (dist - ball.radius > ring.radius + ring.thickness) {
                    rings.splice(i, 1);
                }
            }

            let ballAngle = Math.atan2(ball.y, ball.x);
            if (ballAngle < 0) ballAngle += Math.PI * 2;

            rings.forEach(ring => {
                const distToRing = dist - ring.radius;

                if (Math.abs(distToRing) < ball.radius + ring.thickness/2) {
                    let ringAngle = ring.angle % (Math.PI * 2);
                    if (ringAngle < 0) ringAngle += Math.PI * 2;

                    const normalize = (a) => {
                        a = a % (Math.PI * 2);
                        if (a < 0) a += Math.PI * 2;
                        return a;
                    };

                    const relativeAngle = normalize(ballAngle - ringAngle);
                    const halfGap = ring.gapSize / 2;

                    if (relativeAngle >= halfGap && relativeAngle <= Math.PI * 2 - halfGap) {
                        const nx = ball.x / dist;
                        const ny = ball.y / dist;

                        if (dist < ring.radius) {
                             const targetDist = ring.radius - ball.radius - ring.thickness/2;
                             ball.x = nx * targetDist;
                             ball.y = ny * targetDist;
                        } else {
                             const targetDist = ring.radius + ball.radius + ring.thickness/2;
                             ball.x = nx * targetDist;
                             ball.y = ny * targetDist;
                        }

                        const dot = ball.vx * nx + ball.vy * ny;
                        ball.vx = (ball.vx - 2 * dot * nx) * BOUNCE;
                        ball.vy = (ball.vy - 2 * dot * ny) * BOUNCE;

                        const tangentVel = ring.speed * ring.radius;
                        ball.vx += -ny * tangentVel * 0.1;
                        ball.vy += nx * tangentVel * 0.1;
                    }
                }
            });
            
            if (dist > Math.max(width, height)) {
                 resetGame();
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(17, 17, 17, 0.4)';
            ctx.fillRect(0, 0, width, height);

            ball.update();
            checkCollisions();

            rings.forEach(ring => {
                ring.update();
                ring.draw(ctx);
            });

            ball.draw(ctx);
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        });

        window.addEventListener('mousedown', () => resetGame());
        window.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            resetGame();
        });

        init();
        animate();
    </script>
</body>
</html>